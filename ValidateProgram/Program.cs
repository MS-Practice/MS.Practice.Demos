#region 解释说明
/*1.图像预处理。
我的图像预处理，就是二值化图像。
然后，统计一下，白色和黑色的比例。决定是否反转图像的颜色。
为什么要反转图像颜色呢。因为，有些验证码的字符的颜色是浅色背景是深色，
而有些是字符深色背景浅色。为了使后续的操作简单。
把它们都统一处理成字符黑色背景白色。
我的处理是，对于整个图像，如果黑色比例比白色多
那么，就认为黑色是背景。对整个图像进行颜色反转。
 
2.字符分割
字符的分割，我用的是提取连通分量的做法。
连通分量（Connected Component)是图论上的说法，
好像到了图像处理的书，一般都叫连通区域（Connected Region）
(这2个说法都是等价的吧？呵呵，我不知道，期待你来回答我）
提取连通分量的实现一般都是 DFS（深度优先搜索）算法啦。
我写的算法用的是8邻域连通，
把纯黑色的像素都提取出来。
（实际上有一个回调函数，可以在算法外部决定提取什么颜色）
返回的是这些像素的点的坐标。
（有坐标就足够了，已经能够表达形状了，这一步后，根本不需要字符的颜色信息）
数据结构如下：List<Point> Region ;
 

如上图，
界面左边的图像是原图。
先对左边的原图像进行二值化处理。
然后，提取连通分量。
界面右边的图像，用于调试。
我把提取到的每个独立的连通分量都染成了红色。
并且，遍历了那些连通分量上的点，计算出最小包围矩形。
矩形用蓝色显示。
提取连通分量有一个好处，就是不管字符在图像的什么位置
都可以“抓”到它。当然，这个是需要有颜色信息分明的前提的。
 
3.对分割后的信息提取特征
提取到连通分量后，就可以计算特征了。
特征计算目的就是把高维度的表示降成低维度的表示。
我的理解，就是说，“去掉很多细节表示，只留下个大概模糊的轮廓描述”
特征提取，方法很多。比如：矩（Moment）
因为我水平有限。！- -
So，这里使用的是一种简单的“N*M比例特征法“
就是把连通分量按照每个点的几何位置信息先套上一个最小包围矩形
然后，把这个矩形分割为N行M列的小格子。
再然后，把连通分量的点按照位置信息归类进对应的小格子中。
最后，计算小格子中的点的数量与小格子的面积的比值。
每个小格子最后对应一个标量。
我是5*5切分，所以，最后25个标量，
组成一个25维的向量作为一个连通分量的特征。
 
4.用特征和样本进行匹配
最后一步，分类。也就是识别。
分类器搞到很复杂的有什么：支持向量机，人工神经网络 等
同样是水平有限，这里，我实现了最简单的分类：最近邻法
最近邻法就是说，把要匹配的特征和样本库中的所有样本特征进行计算
取欧氏距离最短的那个样本的类别作为输出
 
 
最后说下，
为什么会对网址4的验证码识别率很低呢
最主要的原因出在分割这个环节上。如下图：

如果能正确分割出字符，获取其形状描述（点集合）
那么，就可以达到100%识别。
我实现的只是简单的阈值化。没有用自适应阈值。
所以，阈值后，不一定会”凸显“字符的轮廓。
其实，这个码可能用自适应阈值也不好处理，
因为，字符灰度值有可能比局部计算出来的阈值灰度值低或高
所以，到底定义比自适应阈值的阈值是高还是低呢？
如果舍得花费功夫的话，用一些统计学的方法
*/

#endregion
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace ValidateProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            string newpath = Path.Combine("amd", "sum");
            int i = 5, k;
            k = ++i + i--;
            Console.WriteLine(k.ToString());
            Console.Read();
        }
    }
}
